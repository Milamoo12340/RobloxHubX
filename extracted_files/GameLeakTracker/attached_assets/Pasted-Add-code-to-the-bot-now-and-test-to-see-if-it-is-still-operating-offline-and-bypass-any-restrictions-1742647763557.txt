Add code to the bot now and test to see if it is still operating offline and bypass any restrictions that are making it not stay online add all your suggested code to fix the online status and change it now I will test the bot when you're done

import fs from 'fs';
import path from 'path';
import { Client, GatewayIntentBits } from 'discord.js';

// Create a new Discord client instance
const client = new Client({ intents: [GatewayIntentBits.Guilds, GatewayIntentBits.GuildMessages, GatewayIntentBits.MessageContent] });

// File path for caching commands
const cacheFilePath = path.join(__dirname, 'commandsCache.json');
let commandCache: Record<string, any> = {};

// Load cached commands from file if it exists
if (fs.existsSync(cacheFilePath)) {
    const cachedData = fs.readFileSync(cacheFilePath, 'utf8');
    commandCache = JSON.parse(cachedData);
}

// Function to execute commands
private async executeCommand(command: string, args: string[]) {
    try {
        // Your command execution logic (implement as needed)
        const result = await this.processCommand(command, args);
        this.sendMessageToChannel(result);
    } catch (error) {
        console.error(`Error executing command ${command}:`, error);
    }
}

// Cache command response when offline
private cacheCommand(command: string, args: any) {
    commandCache[command] = args;
    fs.writeFileSync(cacheFilePath, JSON.stringify(commandCache));
}

client.on('messageCreate', async (message) => {
    if (message.author.bot) return;

    const args = message.content.split(' ');
    const command = args.shift()?.toLowerCase();

    if (this.isOnline) {
        await this.executeCommand(command, args);
    } else {
        // Cache command if the bot is offline
        this.cacheCommand(command, args);
        console.log(`Command ${command} cached while offline.`);
    }
});

private async startBot() {
    await this.initializeBot();
    this.checkBotStatus(); // Start the status check
}

private checkBotStatus() {
    setInterval(async () => {
        try {
            // Attempt to ping the Discord API
            const response = await fetch('https://discord.com/api/v9/users/@me', {
                method: 'GET',
                headers: {
                    'Authorization': `Bot ${process.env.DISCORD_BOT_TOKEN}`
                }
            });

            if (!response.ok) {
                console.error('Bot is offline, attempting to reconnect...');
                await this.reconnect();
            } else {
                console.log('Bot is online.');
            }
        } catch (error) {
            console.error('Error checking bot status:', error);
            await this.reconnect();
        }
    }, 60000); // Check every 60 seconds
}

private async reconnect() {
    await this.initializeBot();
    console.log('Reconnected successfully.');

    // Process cached commands after reconnecting
    for (const [command, data] of Object.entries

Check build is correct also 

Also check these 

import fs from 'fs';
import path from 'path';

// Caching file path
const cacheFilePath = path.join(__dirname, 'commandsCache.json');

// This will hold the cached commands
let commandCache: Record<string, any> = {};

// Load cached commands from file if it exists
if (fs.existsSync(cacheFilePath)) {
    const cachedData = fs.readFileSync(cacheFilePath, 'utf8');
    commandCache = JSON.parse(cachedData);
}

// Function to execute commands
private async executeCommand(command: string, args: string[]) {
    try {
        // Your command execution logic (to be implemented as per your app requirements)
        const result = await this.processCommand(command, args);
        this.sendMessageToChannel(result);
    } catch (error) {
        console.error(`Error executing command ${command}:`, error);
    }
}

// Store command result when offline
private cacheCommand(command: string, result: any) {
    commandCache[command] = result;
    fs.writeFileSync(cacheFilePath, JSON.stringify(commandCache));
}

// Listen for commands
this.client.on('messageCreate', async (message) => {
    if (message.author.bot) return;
    
    const args = message.content.split(' ');
    const command = args.shift()?.toLowerCase();

    if (this.isOnline) {
        await this.executeCommand(command, args);
    } else {
        // When offline, cache the command result (you can customize this logic)
        this.cacheCommand(command, { args });
        console.log(`Command ${command} cached while offline.`);
    }
});

// After reconnecting
private async reconnect() {
    await this.initializeBot();
    console.log('Reconnected successfully.');
    
    // Process any cached commands after reconnecting
    for (const [command, data] of Object.entries(commandCache)) {
        await this.executeCommand(command, data.args);
        delete commandCache[command]; // Optionally remove once processed
    }
    // Clear the cache file after processing
    fs.writeFileSync(cacheFilePath, JSON.stringify({}));
}

// Existing reconnection logic (modified)
private async reconnect() {
    await this.initializeBot();
    console.log('Reconnected successfully.');

    // Process all cached commands
    Object.keys(commandCache).forEach(async command => {
        const cachedData = commandCache[command];
        await this.executeCommand(command, cachedData.args);
        delete commandCache[command]; // Clear after processing
    });
    
    fs.writeFileSync(cacheFilePath, JSON.stringify({})); // Clear cache file
}

private checkBotStatus() {
    setInterval(async () => {
        try {
            // Attempt to ping the bot's server or Discord API
            const response = await fetch('https://discord.com/api/v9/users/@me', {
                method: 'GET',
                headers: {
                    'Authorization': `Bot ${process.env.DISCORD_BOT_TOKEN}`
                }
            });

            // If the response is not okay, try to reconnect
            if (!response.ok) {
                console.error('Bot is offline, attempting to reconnect...');
                await this.reconnect();
            } else {
                console.log('Bot is online.');
            }
        } catch (error) {
            console.error('Error checking bot status:', error);
            await this.reconnect();
        }
    }, 60000); // Check every 60 seconds
}

private async reconnect() {
    // You can implement reconnection logic, such as logging back in or resetting the bot
    // For example, we can re-initialize the bot if it has gone offline
    await this.initializeBot(); // Ensure you have a method to initialize the bot
    console.log('Reconnected successfully.');
}

private async initializeBot() {
    // Your bot initialization logic here
    // For example, log the bot in
    await this.client.login(process.env.DISCORD_BOT_TOKEN);
}

// Call checkBotStatus in your bot's main initialization
async startBot() {
    await this.initializeBot();
    this.checkBotStatus(); // Start the status check
}

Test the bot
